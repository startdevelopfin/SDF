<!doctype html>
<html data-bs-theme="auto" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <meta content="Daniel J. Aupont" name="author" />
    <meta content="Ignite v0.2.1" name="generator" />
    <title>SwiftUI Fundamentals - The second example app TemperatureConverter 2.0 ‚Äì Swift Blog Site</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-xcode-dark.css" rel="stylesheet" data-highlight-theme="xcode-dark" />
    <link href="/css/prism-xcode-light.css" rel="stylesheet" data-highlight-theme="xcode-light" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://startdevelopfinish.com/t-c-part2" rel="canonical" />
    <script>(function() {
    function getThemePreference() {
        return localStorage.getItem('custom-theme') || 'auto';
    }

    function applyTheme(themeID) {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const lightThemeID = document.documentElement.getAttribute('data-light-theme') || 'light';
        const darkThemeID = document.documentElement.getAttribute('data-dark-theme') || 'dark';
        const actualThemeID = themeID === 'auto' ? (prefersDark ? darkThemeID : lightThemeID) : themeID;

        document.documentElement.setAttribute('data-bs-theme', actualThemeID);
        document.documentElement.setAttribute('data-theme-state', themeID);
    }

    function applySyntaxTheme() {
        const syntaxTheme = getComputedStyle(document.documentElement)
            .getPropertyValue('--syntax-highlight-theme').trim().replace(/"/g, '');

        if (!syntaxTheme) return;

        document.querySelectorAll('link[data-highlight-theme]').forEach(link => {
            link.setAttribute('disabled', 'disabled');
        });

        const themeLink = document.querySelector(`link[data-highlight-theme="${syntaxTheme}"]`);
        if (themeLink) {
            themeLink.removeAttribute('disabled');
        }
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const currentTheme = getThemePreference();
        if (currentTheme === 'auto') {
            applyTheme('auto');
            applySyntaxTheme();
        }
    });

    const savedTheme = getThemePreference();
    applyTheme(savedTheme);
    applySyntaxTheme();
})();
</script>
    <meta content="Start. Develop. Finish." property="og:site_name" />
    <meta content="SwiftUI Fundamentals - The second example app TemperatureConverter 2.0" property="og:title" />
    <meta content="SwiftUI Fundamentals - The second example app TemperatureConverter 2.0" name="twitter:title" />
    <meta content="https://startdevelopfinish.com/t-c-part2" property="og:url" />
    <meta content="startdevelopfinish.com" name="twitter:domain" />
    <meta content="summary_large_image" name="twitter:card" />
    <meta content="on" name="twitter:dnt" />
  </head>
  <body class="container">
    <header>
      <nav class="fixed-top navbar navbar-expand-md" style="background-color: rgb(0 0 0 / 100%)" data-bs-theme="dark">
        <div class="container">
          <a href="/" class="link-underline link-underline-opacity-100 link-underline-opacity-100-hover navbar-brand"><p class="mb-0">Start. <span style="color: #6B8E23;">Develop</span>. Finish.</p></a>
          <button type="button" class="btn navbar-toggler" data-bs-target="#navbarCollapse" data-bs-toggle="collapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
          <div id="navbarCollapse" class="collapse navbar-collapse">
            <ul class="col justify-content-end mb-2 mb-md-0 navbar-nav">
              <li class="dropdown nav-item" data-bs-theme="light"><a href="#" role="button" class="dropdown dropdown-toggle link-underline link-underline-opacity-100 link-underline-opacity-100-hover nav-link" data-bs-toggle="dropdown" aria-expanded="false">SwiftUI Tutorials</a>
                <ul class="dropdown dropdown-menu"></ul></li>
              <li class="dropdown nav-item" data-bs-theme="light"><a href="#" role="button" class="dropdown dropdown-toggle link-underline link-underline-opacity-100 link-underline-opacity-100-hover nav-link" data-bs-toggle="dropdown" aria-expanded="false">App Store</a>
                <ul class="dropdown dropdown-menu">
                  <li><a href="/by-rule" class="dropdown-item link-underline link-underline-opacity-100 link-underline-opacity-100-hover">By Rule</a></li>
                </ul></li>
              <li class="dropdown nav-item" data-bs-theme="light"><a href="#" role="button" class="dropdown dropdown-toggle link-underline link-underline-opacity-100 link-underline-opacity-100-hover nav-link" data-bs-toggle="dropdown" aria-expanded="false">Info</a>
                <ul class="dropdown dropdown-menu">
                  <li><a href="/about" class="dropdown-item link-underline link-underline-opacity-100 link-underline-opacity-100-hover">About</a></li>
                </ul></li>
            </ul>
          </div>
        </div>
      </nav>
    </header>
    <div class="row">
      <div class="col-md-9">
        <div style="padding-bottom: 80px; padding-top: 80px">
          <h1 class="my-4" style="font-weight: 700; padding: 4px">SwiftUI Fundamentals üöÄ</h1>
          <p class="my-3" style="font-weight: 600; padding: 4px">Part 2: Leveling up our TemperatureConverter app with advanced Swift concepts</p>
          <div class="my-3 ratio ratio-4x3" style="background-color: rgb(143 188 143 / 50%); border: 6.0px solid rgb(176 224 230 / 100%); border-radius: 12px; height: 400px; overflow: hidden">
            <img alt="" src="https://firebasestorage.googleapis.com/v0/b/by-rule-90fbd.appspot.com/o/swiftuiweekly%2FTC01.png?alt=media&amp;token=1da40d82-d6b2-4ef4-816e-8a75afca1b26" class="img-fluid object-fit-contain" />
          </div>
          <h3 class="my-4">To Be Continued...üöß</h3>
          <p class="my-4" style="line-height: 1.8">Last week, I created a simple Temperature Converter app using basic Swift concepts. This week, lets take it to the next level by implementing more advanced Swift features. In this post, we will explore how they can make our code more robust, maintainable, and scalable.</p>
          <h3 class="my-4">Enhanced Temperature Converter App üå°Ô∏è</h3>
          <p class="my-4" style="line-height: 1.8">Here's how I've updated the app:</p>
          <ul class="my-4">
            <li><p class="m-0">Improved the UI with validation feedback</p></li>
            <li><p class="m-0">Implemented error handling for invalid inputs</p></li>
            <li><p class="m-0">Added decimal place precision control</p></li>
            <li><p class="m-0">Created a robust architecture using protocols and classes</p></li>
            <li><p class="m-0">Added conversion history tracking</p></li>
          </ul>
          <h3 class="my-4">Error Handling with Throwing Functions ‚ö†Ô∏è</h3>
          <p class="my-4" style="line-height: 1.8">Instead of silently failing when users enter invalid input, we can use Swift's error handling system to provide meaningful feedback.</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">/// Errors that can occur during temperature conversion.
enum TemperatureError: Error {
case invalidInput
    
    /// User-friendly error description.
    var localizedDescription: String {
        switch self {
        case .invalidInput:
            return "Please enter a valid number for the temperature."
        }
    }
}

// A throwing function that validates and converts temperature
func convert(_ value: String, from fromUnit: TemperatureUnit, to toUnit: TemperatureUnit) throws -&gt; Double {
    guard let inputValue = Double(value) else {
        throw TemperatureError.invalidInput
    }
}</code></pre>
          <p class="my-4" style="line-height: 1.8">Using the throws keyword tells Swift that this function can throw errors, which must be handled by the caller using do-try-catch. This makes the app more robust by gracefully handling errors rather than simply crashing.</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">do {
    let result = try converter.convert(inputTemperature, from: fromUnit, to: toUnit)
    // Use the result
} catch TemperatureError.invalidInput {
    // Handle invalid input error
} catch {
    // All other errors
}</code></pre>
          <h3 class="my-4">Optionals for Error Handling üîÑ</h3>
          <p class="my-4" style="line-height: 1.8">I use an optional String to represent an error message that might or might not exist:</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">@State private var errorMessage: String? = nil</code></pre>
          <p class="my-4" style="line-height: 1.8">When displaying it, I use nil coalescing to provide a default. This is a clean way to handle potentially absent values:</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">Text(errorMessage ?? "An unknown error occurred")</code></pre>
          <h3 class="my-4">Protocols and Classes for Conversion Logic üß©</h3>
          <p class="my-4" style="line-height: 1.8">The original app had conversion logic embedded directly in the view. Now, I've extracted it into a proper architecture using protocols and classes:</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">// Define a protocol for temperature conversion
protocol TemperatureConvertible {
    func convert(_ value: String, from fromUnit: TemperatureUnit, to toUnit: TemperatureUnit) throws -&gt; Double
    func formatTemperature(_ value: Double, decimalPlaces: Int) -&gt; String
}

// Implement the protocol in a class
final class TemperatureConverter: TemperatureConvertible {
    // Singleton pattern with static shared instance
    static let shared = TemperatureConverter()
    
    private init() {}
    
    /// Converts a temperature value from one unit to another.
    /// - Parameters:
    ///   - value: The temperature value to convert as a string.
    ///   - fromUnit: The unit of the input temperature.
    ///   - toUnit: The unit to convert the temperature to.
    /// - Returns: The converted temperature value.
    /// - Throws: `TemperatureError.invalidInput` if the provided value is not a valid number.
    func convert(_ value: String, from fromUnit: TemperatureUnit, to toUnit: TemperatureUnit) throws -&gt; Double {
        // If input and output units are the same, return the original value
        if fromUnit == toUnit, let doubleValue = Double(value) {
            return doubleValue
        }
        
        guard let inputValue = Double(value) else {
            throw TemperatureError.invalidInput
        }
        
        // Convert to celsius first (base unit for conversion)
        let valueInCelsius = toCelsius(inputValue, from: fromUnit)
        
        // Then convert from celsius to the desired output unit
        return fromCelsius(valueInCelsius, to: toUnit)
    }
    
    /// Formats a temperature value with the specified number of decimal places.
    /// - Parameters:
    ///   - value: The temperature value to format.
    ///   - decimalPlaces: The number of decimal places to include (default is 2).
    /// - Returns: A formatted string representation of the temperature.
    func formatTemperature(_ value: Double, decimalPlaces: Int = 2) -&gt; String {
        return String(format: "%.(decimalPlaces)f", value)
    }
    
    /// Converts a temperature from any unit to Celsius.
    /// - Parameters:
    ///   - value: The temperature value to convert.
    ///   - unit: The unit of the temperature value.
    /// - Returns: The temperature value in Celsius.
    private func toCelsius(_ value: Double, from unit: TemperatureUnit) -&gt; Double {
        switch unit {
        case .celsius:
            return value
        case .fahrenheit:
            return (value - 32) * 5 / 9
        case .kelvin:
            return value - 273.15
        }
    }
    
    /// Converts a temperature from Celsius to another unit.
    /// - Parameters:
    ///   - value: The temperature value in Celsius.
    ///   - unit: The unit to convert the temperature to.
    /// - Returns: The converted temperature value.
    private func fromCelsius(_ value: Double, to unit: TemperatureUnit) -&gt; Double {
        switch unit {
        case .celsius:
            return value
        case .fahrenheit:
            return (value * 9 / 5) + 32
        case .kelvin:
            return value + 273.15
        }
    }
}</code></pre>
          <p class="my-4" style="line-height: 1.8">This approach gives us:</p>
          <ul class="my-4">
            <li><p class="m-0">Protocol-based design: Clear contract for what a temperature converter should do</p></li>
            <li><p class="m-0">Singleton pattern: Easy access to the converter throughout the app</p></li>
            <li><p class="m-0">Access control: Public API with private implementation details</p></li>
            <li><p class="m-0">Default parameter values: Convenience for common cases</p></li>
          </ul>
          <h3 class="my-4">Structs and Computed Properties for History Tracking üï∞Ô∏è</h3>
          <p class="my-4" style="line-height: 1.8">To track conversion history, I use a struct with computed properties:</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">/// Represents a temperature conversion record.
struct TemperatureRecord: Identifiable {
    /// Unique identifier for the record.
    let id = UUID()
    
    /// The original temperature value entered by the user.
    let inputValue: String
    
    /// The unit of the input temperature.
    let fromUnit: TemperatureUnit
    
    /// The unit of the output temperature.
    let toUnit: TemperatureUnit
    
    /// The converted temperature value.
    let result: String
    
    /// The date and time when the conversion was performed.
    let timestamp: Date = Date()
    
    /// Formatted timestamp for display purposes.
    var formattedTimestamp: String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        return formatter.string(from: timestamp)
    }
}</code></pre>
          <p class="my-4" style="line-height: 1.8">The formattedTimestamp computed property dynamically formats the timestamp whenever it's accessed, without needing to store the formatted string.</p>
          <h3 class="my-4">Using Closures for Button Actions üîò</h3>
          <p class="my-4" style="line-height: 1.8">In SwiftUI, we frequently use closures for button actions:</p>
          <pre style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px"><code class="language-swift">Button(action: {
    convertAndSave()  // This is a closure!
}) {
    Text("Save Conversion")
        .padding()
        .frame(maxWidth: .infinity)
        .background(Color.blue)
        .foregroundColor(.white)
        .cornerRadius(8)
}</code></pre>
          <p class="my-4" style="line-height: 1.8">The closure executes when the button is tapped. This is a powerful example of passing functions into functions.</p>
          <h3 class="my-4">Key Terms I'm Adding to My Vocabulary üìù</h3>
          <table class="my-4 table" style="border: 6.0px solid rgb(0 0 0 / 100%); border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; border-top-left-radius: 12px; border-top-right-radius: 12px">
            <tbody>
              <tr>
                <td><h5 style="font-weight: 700">Term</h5></td>
                <td><h5 style="font-weight: 700">Definition</h5></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Throwing Functions</p></td>
                <td><p>Functions that can signal errors using Swift's throw mechanism</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Protocol</p></td>
                <td><p>A blueprint of methods and properties that conforming types must implement</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Computed Property</p></td>
                <td><p>A property that runs code to determine its value rather than storing it</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Access Control</p></td>
                <td><p>Restricting access to parts of your code with keywords like private and public</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Extension</p></td>
                <td><p>A way to add functionality to existing types without subclassing</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Nil Coalescing</p></td>
                <td><p>The ?? operator that provides a default value when an optional is nil</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Closure</p></td>
                <td><p>Self-contained blocks of functionality that can be passed around and used in your code</p></td>
              </tr>
              <tr>
                <td><p style="font-weight: 600">Singleton Pattern</p></td>
                <td><p>A design pattern ensuring a class has only one instance with global access</p></td>
              </tr>
            </tbody>
          </table>
          <h3 class="my-4">Resources I Found Helpful ‚ö°Ô∏è</h3>
          <ul class="my-4">
            <li><a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html" class="link-underline link-underline-opacity-100 link-underline-opacity-100-hover m-0" style="font-weight: 700">Swift.org - Error Handling</a></li>
          </ul>
          <hr class="my-4" />
          <p>See the complete implementation GitHub</p>
          <a href="https://github.com/startdevelopfin/TemperatureConverter" class="link-underline link-underline-opacity-100 link-underline-opacity-100-hover">Temperature Converter</a>
          <p class="mt-4" style="font-weight: 300">SwiftUI Fundamentals - The second example app TemperatureConverter 2.0</p>
        </div>
      </div>
    </div>
    <p class="mt-5 text-center">Created in Swift with <a href="https://github.com/twostraws/Ignite" class="link-underline link-underline-opacity-100 link-underline-opacity-100-hover">Ignite</a></p>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>